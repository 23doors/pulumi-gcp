// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package cloudbuild

import (
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// > This content is derived from https://github.com/terraform-providers/terraform-provider-google/blob/master/website/docs/r/cloudbuild_trigger.html.markdown.
type Trigger struct {
	s *pulumi.ResourceState
}

// NewTrigger registers a new resource with the given unique name, arguments, and options.
func NewTrigger(ctx *pulumi.Context,
	name string, args *TriggerArgs, opts ...pulumi.ResourceOpt) (*Trigger, error) {
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["build"] = nil
		inputs["description"] = nil
		inputs["disabled"] = nil
		inputs["filename"] = nil
		inputs["github"] = nil
		inputs["ignoredFiles"] = nil
		inputs["includedFiles"] = nil
		inputs["name"] = nil
		inputs["project"] = nil
		inputs["substitutions"] = nil
		inputs["triggerTemplate"] = nil
	} else {
		inputs["build"] = args.Build
		inputs["description"] = args.Description
		inputs["disabled"] = args.Disabled
		inputs["filename"] = args.Filename
		inputs["github"] = args.Github
		inputs["ignoredFiles"] = args.IgnoredFiles
		inputs["includedFiles"] = args.IncludedFiles
		inputs["name"] = args.Name
		inputs["project"] = args.Project
		inputs["substitutions"] = args.Substitutions
		inputs["triggerTemplate"] = args.TriggerTemplate
	}
	inputs["createTime"] = nil
	inputs["triggerId"] = nil
	s, err := ctx.RegisterResource("gcp:cloudbuild/trigger:Trigger", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &Trigger{s: s}, nil
}

// GetTrigger gets an existing Trigger resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTrigger(ctx *pulumi.Context,
	name string, id pulumi.ID, state *TriggerState, opts ...pulumi.ResourceOpt) (*Trigger, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["build"] = state.Build
		inputs["createTime"] = state.CreateTime
		inputs["description"] = state.Description
		inputs["disabled"] = state.Disabled
		inputs["filename"] = state.Filename
		inputs["github"] = state.Github
		inputs["ignoredFiles"] = state.IgnoredFiles
		inputs["includedFiles"] = state.IncludedFiles
		inputs["name"] = state.Name
		inputs["project"] = state.Project
		inputs["substitutions"] = state.Substitutions
		inputs["triggerId"] = state.TriggerId
		inputs["triggerTemplate"] = state.TriggerTemplate
	}
	s, err := ctx.ReadResource("gcp:cloudbuild/trigger:Trigger", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &Trigger{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *Trigger) URN() *pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *Trigger) ID() *pulumi.IDOutput {
	return r.s.ID()
}

// Contents of the build template. Either a filename or build template must be provided.
func (r *Trigger) Build() *pulumi.Output {
	return r.s.State["build"]
}

// Time when the trigger was created.
func (r *Trigger) CreateTime() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["createTime"])
}

// Human-readable description of the trigger.
func (r *Trigger) Description() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["description"])
}

// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
func (r *Trigger) Disabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["disabled"])
}

// Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must
// be provided.
func (r *Trigger) Filename() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["filename"])
}

// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
func (r *Trigger) Github() *pulumi.Output {
	return r.s.State["github"]
}

// ignoredFiles and includedFiles are file glob matches using http://godoc/pkg/path/filepath#Match extended with support
// for '**'. If ignoredFiles and changed files are both empty, then they are not used to determine whether or not to
// trigger a build. If ignoredFiles is not empty, then we ignore any files that match any of the ignored_file globs. If the
// change has no files that are outside of the ignoredFiles globs, then we do not trigger a build.
func (r *Trigger) IgnoredFiles() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["ignoredFiles"])
}

// ignoredFiles and includedFiles are file glob matches using http://godoc/pkg/path/filepath#Match extended with support
// for '**'. If any of the files altered in the commit pass the ignoredFiles filter and includedFiles is empty, then as far
// as this filter is concerned, we should trigger the build. If any of the files altered in the commit pass the
// ignoredFiles filter and includedFiles is not empty, then we make sure that at least one of those files matches a
// includedFiles glob. If not, then we do not trigger a build.
func (r *Trigger) IncludedFiles() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["includedFiles"])
}

// Name of the trigger. Must be unique within the project.
func (r *Trigger) Name() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["name"])
}

// The ID of the project in which the resource belongs.
// If it is not provided, the provider project is used.
func (r *Trigger) Project() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["project"])
}

// Substitutions data for Build resource.
func (r *Trigger) Substitutions() *pulumi.MapOutput {
	return (*pulumi.MapOutput)(r.s.State["substitutions"])
}

// The unique identifier for the trigger.
func (r *Trigger) TriggerId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["triggerId"])
}

// Template describing the types of source changes to trigger a build. Branch and tag names in trigger templates are
// interpreted as regular expressions. Any branch or tag change that matches that regular expression will trigger a build.
// This field is required, and will be validated as such in 3.0.0.
func (r *Trigger) TriggerTemplate() *pulumi.Output {
	return r.s.State["triggerTemplate"]
}

// Input properties used for looking up and filtering Trigger resources.
type TriggerState struct {
	// Contents of the build template. Either a filename or build template must be provided.
	Build interface{}
	// Time when the trigger was created.
	CreateTime interface{}
	// Human-readable description of the trigger.
	Description interface{}
	// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
	Disabled interface{}
	// Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must
	// be provided.
	Filename interface{}
	// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
	Github interface{}
	// ignoredFiles and includedFiles are file glob matches using http://godoc/pkg/path/filepath#Match extended with support
	// for '**'. If ignoredFiles and changed files are both empty, then they are not used to determine whether or not to
	// trigger a build. If ignoredFiles is not empty, then we ignore any files that match any of the ignored_file globs. If
	// the change has no files that are outside of the ignoredFiles globs, then we do not trigger a build.
	IgnoredFiles interface{}
	// ignoredFiles and includedFiles are file glob matches using http://godoc/pkg/path/filepath#Match extended with support
	// for '**'. If any of the files altered in the commit pass the ignoredFiles filter and includedFiles is empty, then as
	// far as this filter is concerned, we should trigger the build. If any of the files altered in the commit pass the
	// ignoredFiles filter and includedFiles is not empty, then we make sure that at least one of those files matches a
	// includedFiles glob. If not, then we do not trigger a build.
	IncludedFiles interface{}
	// Name of the trigger. Must be unique within the project.
	Name interface{}
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project interface{}
	// Substitutions data for Build resource.
	Substitutions interface{}
	// The unique identifier for the trigger.
	TriggerId interface{}
	// Template describing the types of source changes to trigger a build. Branch and tag names in trigger templates are
	// interpreted as regular expressions. Any branch or tag change that matches that regular expression will trigger a build.
	// This field is required, and will be validated as such in 3.0.0.
	TriggerTemplate interface{}
}

// The set of arguments for constructing a Trigger resource.
type TriggerArgs struct {
	// Contents of the build template. Either a filename or build template must be provided.
	Build interface{}
	// Human-readable description of the trigger.
	Description interface{}
	// Whether the trigger is disabled or not. If true, the trigger will never result in a build.
	Disabled interface{}
	// Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must
	// be provided.
	Filename interface{}
	// Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
	Github interface{}
	// ignoredFiles and includedFiles are file glob matches using http://godoc/pkg/path/filepath#Match extended with support
	// for '**'. If ignoredFiles and changed files are both empty, then they are not used to determine whether or not to
	// trigger a build. If ignoredFiles is not empty, then we ignore any files that match any of the ignored_file globs. If
	// the change has no files that are outside of the ignoredFiles globs, then we do not trigger a build.
	IgnoredFiles interface{}
	// ignoredFiles and includedFiles are file glob matches using http://godoc/pkg/path/filepath#Match extended with support
	// for '**'. If any of the files altered in the commit pass the ignoredFiles filter and includedFiles is empty, then as
	// far as this filter is concerned, we should trigger the build. If any of the files altered in the commit pass the
	// ignoredFiles filter and includedFiles is not empty, then we make sure that at least one of those files matches a
	// includedFiles glob. If not, then we do not trigger a build.
	IncludedFiles interface{}
	// Name of the trigger. Must be unique within the project.
	Name interface{}
	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	Project interface{}
	// Substitutions data for Build resource.
	Substitutions interface{}
	// Template describing the types of source changes to trigger a build. Branch and tag names in trigger templates are
	// interpreted as regular expressions. Any branch or tag change that matches that regular expression will trigger a build.
	// This field is required, and will be validated as such in 3.0.0.
	TriggerTemplate interface{}
}
